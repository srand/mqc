package main

import (
	"flag"
	"fmt"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
)

const version = "1.0.0"

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-mqc %v\n", version)
		return
	}

	protogen.Options{
		ParamFunc: flag.Set,
	}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// Makes leading character lowercase
func unexport(name string) string {
	if len(name) == 0 {
		return ""
	}
	return string(unicode.ToLower(rune(name[0]))) + name[1:]
}

func clientStreamInterface(g *protogen.GeneratedFile, method *protogen.Method) string {
	typeParam := g.QualifiedGoIdent(method.Input.GoIdent) + ", " + g.QualifiedGoIdent(method.Output.GoIdent)
	if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
		return "mqc.BidiStreamClient[" + typeParam + "]"
	} else if method.Desc.IsStreamingClient() {
		return "mqc.ClientStreamClient[" + typeParam + "]"
	} else { // i.e. if method.Desc.IsStreamingServer()
		return "mqc.ServerStreamClient[" + method.Output.GoIdent.GoName + "]"
	}
}

func clientSignature(g *protogen.GeneratedFile, m *protogen.Method) string {
	if m.Desc.IsStreamingClient() && m.Desc.IsStreamingServer() {
		return fmt.Sprintf("%s(ctx context.Context) (%s, error)", m.GoName, clientStreamInterface(g, m))
	} else if m.Desc.IsStreamingClient() {
		return fmt.Sprintf("%s(ctx context.Context) (%s, error)", m.GoName, clientStreamInterface(g, m))
	} else if m.Desc.IsStreamingServer() {
		return fmt.Sprintf("%s(ctx context.Context, req *%s) (%s, error)", m.GoName, m.Input.GoIdent.GoName, clientStreamInterface(g, m))
	}
	return fmt.Sprintf("%s(ctx context.Context, req *%s) (*%s, error)", m.GoName, m.Input.GoIdent.GoName, m.Output.GoIdent.GoName)
}

func serverStreamInterface(g *protogen.GeneratedFile, method *protogen.Method) string {
	typeParam := g.QualifiedGoIdent(method.Input.GoIdent) + ", " + g.QualifiedGoIdent(method.Output.GoIdent)
	if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
		return "mqc.BidiStreamServer[" + typeParam + "]"
	} else if method.Desc.IsStreamingClient() {
		return "mqc.ClientStreamServer[" + typeParam + "]"
	} else { // i.e. if method.Desc.IsStreamingServer()
		return "mqc.ServerStreamServer[" + g.QualifiedGoIdent(method.Output.GoIdent) + "]"
	}
}

func serverSignature(g *protogen.GeneratedFile, m *protogen.Method) string {
	if m.Desc.IsStreamingClient() && m.Desc.IsStreamingServer() {
		return fmt.Sprintf("%s(stream %s) error", m.GoName, serverStreamInterface(g, m))
	} else if m.Desc.IsStreamingClient() {
		return fmt.Sprintf("%s(stream %s) error", m.GoName, serverStreamInterface(g, m))
	} else if m.Desc.IsStreamingServer() {
		return fmt.Sprintf("%s(req *%s, stream %s) error", m.GoName, m.Input.GoIdent.GoName, serverStreamInterface(g, m))
	}
	return fmt.Sprintf("%s(req *%s) (*%s, error)", m.GoName, m.Input.GoIdent.GoName, m.Output.GoIdent.GoName)
}

func generateFile(gen *protogen.Plugin, f *protogen.File) {
	g := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+".mqc.pb.go", f.GoImportPath)
	g.P("// Code generated by protoc-gen-mqc. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// protoc-gen-go-mqc v%v", version))
	g.P()
	g.P("package ", f.GoPackageName)
	g.P()
	generateFileContent(g, f)
}

func generateFileContent(g *protogen.GeneratedFile, f *protogen.File) {
	// generate imports
	generateImports(g)

	// generate service interfaces
	for _, svc := range f.Services {
		generateClientInterface(g, svc)
		generateServerInterface(g, svc)
	}

	// generate client structs and methods
	for _, svc := range f.Services {
		generateClient(g, svc)
	}

	// generate server structs and methods
	for _, svc := range f.Services {
		generateServerStub(g, svc)
		generateServerRegistration(g, svc)
	}
}

func generateClientInterface(g *protogen.GeneratedFile, svc *protogen.Service) {
	// generate service interface
	g.P("type ", svc.GoName, "Client interface {")
	for _, m := range svc.Methods {
		g.P(clientSignature(g, m))
	}
	g.P("}")
	g.P()
}

func generateServerInterface(g *protogen.GeneratedFile, svc *protogen.Service) {
	// generate service interface
	g.P("type ", svc.GoName, "Server interface {")
	for _, m := range svc.Methods {
		g.P(serverSignature(g, m))
	}
	g.P("}")
	g.P()
}

func generateClient(g *protogen.GeneratedFile, svc *protogen.Service) {
	typeName := unexport(svc.GoName) + "Client"

	// generate client struct
	g.P("type ", typeName, " struct {")
	g.P("transport mqc.Transport")
	g.P("}")
	g.P()

	// generate client constructor
	g.P("func New", svc.GoName, "Client(transport mqc.Transport) *", typeName, " {")
	g.P("return &", typeName, "{transport: transport}")
	g.P("}")
	g.P()

	// generate client methods
	for _, m := range svc.Methods {
		g.P("func (c *", typeName, ") ", clientSignature(g, m), " {")
		if m.Desc.IsStreamingClient() && m.Desc.IsStreamingServer() {
			g.P("return mqc.NewBidiStreamClient[", g.QualifiedGoIdent(m.Input.GoIdent), ", ", g.QualifiedGoIdent(m.Output.GoIdent), "](ctx, c.transport, mqc.Method(\"", svc.GoName, "/", m.GoName, "\"))")
		} else if m.Desc.IsStreamingClient() {
			g.P("return mqc.NewClientStreamClient[", g.QualifiedGoIdent(m.Input.GoIdent), ", ", g.QualifiedGoIdent(m.Output.GoIdent), "](ctx, c.transport, mqc.Method(\"", svc.GoName, "/", m.GoName, "\"))")
		} else if m.Desc.IsStreamingServer() {
			g.P("return mqc.NewServerStreamClient[", g.QualifiedGoIdent(m.Input.GoIdent), ", ", g.QualifiedGoIdent(m.Output.GoIdent), "](ctx, c.transport, mqc.Method(\"", svc.GoName, "/", m.GoName, "\"), req)")
		} else {
			g.P("return mqc.Rpc[", g.QualifiedGoIdent(m.Input.GoIdent), ", ", g.QualifiedGoIdent(m.Output.GoIdent), "](ctx, c.transport, mqc.Method(\"", svc.GoName, "/", m.GoName, "\"), req)")
		}
		g.P("}")
		g.P()
	}
}

func generateServerStub(g *protogen.GeneratedFile, svc *protogen.Service) {
	// generate server struct
	g.P("type Unimplemented", svc.GoName, "Server struct {}")
	g.P()

	// generate unimplemented methods
	for _, m := range svc.Methods {
		g.P("func (s *Unimplemented", svc.GoName, "Server) ", serverSignature(g, m), " {")
		if m.Desc.IsStreamingClient() || m.Desc.IsStreamingServer() {
			g.P("return fmt.Errorf(\"method ", m.GoName, " not implemented\")")
			g.P("}")
			g.P()
			continue
		}
		g.P("return nil, fmt.Errorf(\"method ", m.GoName, " not implemented\")")
		g.P("}")
		g.P()
	}
}

func generateServerRegistration(g *protogen.GeneratedFile, svc *protogen.Service) {
	// Create Register function
	// Handlers are automatically registered
	g.P("func Register", svc.GoName, "Server(transport mqc.Transport, server ", svc.GoName, "Server) {")

	for _, m := range svc.Methods {
		g.P("transport.RegisterHandler(\"", svc.GoName, "/", m.GoName, "\", func(conn mqc.Conn) error {")
		if m.Desc.IsStreamingClient() && m.Desc.IsStreamingServer() {
			g.P("stream, err := mqc.NewBidiStreamServer[", g.QualifiedGoIdent(m.Input.GoIdent), ", ", g.QualifiedGoIdent(m.Output.GoIdent), "](transport, conn)")
			g.P("if err != nil {")
			g.P("return err")
			g.P("}")
			g.P("return server.", m.GoName, "(stream)")
		} else if m.Desc.IsStreamingClient() {
			g.P("stream, err := mqc.NewClientStreamServer[", g.QualifiedGoIdent(m.Input.GoIdent), ", ", g.QualifiedGoIdent(m.Output.GoIdent), "](transport, conn)")
			g.P("if err != nil {")
			g.P("return err")
			g.P("}")
			g.P("return server.", m.GoName, "(stream)")
		} else if m.Desc.IsStreamingServer() {
			g.P("stream, req, err := mqc.NewServerStreamServer[", g.QualifiedGoIdent(m.Input.GoIdent), ", ", g.QualifiedGoIdent(m.Output.GoIdent), "](transport, conn)")
			g.P("if err != nil {")
			g.P("return err")
			g.P("}")
			g.P("return server.", m.GoName, "(req, stream)")
		} else {
			g.P("return mqc.RpcServer(conn, transport.Serializer(), func (req *", g.QualifiedGoIdent(m.Input.GoIdent), ") (*", g.QualifiedGoIdent(m.Output.GoIdent), ", error) {")
			g.P("return server.", m.GoName, "(req)")
			g.P("})")
		}
		g.P("})")
	}
	g.P("}")
	g.P()
}

func generateImports(g *protogen.GeneratedFile) {
	g.P("import (")
	g.P("\"context\"")
	g.P("\"fmt\"")
	g.P("\"github.com/srand/mqc\"")
	g.P(")")
	g.P()
}
